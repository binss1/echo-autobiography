{
  "rules": [
    {
      "type": "prd",
      "content": "# LLM 기반 AI 자서전 작성 플랫폼 PRD (코드명: ECHO)\n\n## 1. 제품 요약\n시니어와 가족이 손쉽게 자신의 삶을 기록하고, AI의 도움으로 고품질 자서전을 완성·출판할 수 있는 웹 기반 플랫폼입니다. 핵심 가치는 \"공감형 AI 인터뷰\"와 \"자동 서사 구조화\"로 글쓰기 부담·비용을 크게 낮추는 것입니다.\n\n---\n\n## 2. 문제 정의\n1. 전문 대필 서비스는 200만~1,600만 원에 달해 시니어에게 경제적 부담이 매우 큼.\n2. 글을 어떻게 시작‧구성해야 할지 막막하여 실제 집필까지 이어지지 못함.\n3. 꾸준히 글을 쓰기 위한 동기·시간 관리가 어렵고 지루함을 느낌.\n4. 기억이 단편적이라 서사 구조를 잡지 못해 완성도가 떨어짐.\n\n---\n\n## 3. 목표 (User Goals)\n1. 가족에게 선물할 물리적 자서전 완성\n2. 자신의 삶을 체계적으로 기록·보존\n3. (세컨드 타깃) 전문 회고록을 통한 개인 브랜딩 강화\n\n성공 지표 (12개월 기준)\n- 무료→유료 전환율 8% 이상\n- 완성된 자서전 수 5,000권\n- NPS 60점 이상(시니어 대상)\n### 초기 3개월 핵심 성과 지표 (Leading KPIs)\n- 활성화율 (Activation Rate): 회원가입 후 24시간 내 첫 번째 '스토리 조각(에피소드)'을 저장한 사용자 비율 (목표: 40%)\n- 주간 리텐션 (Weekly Retention): 가입 1주 후 다시 방문하여 '이어 쓰기'를 진행한 사용자 비율 (목표: 25%)\n- 핵심 기능 사용률 (Core Feature Adoption): 'AI 초안 생성' 기능을 1회 이상 사용해 본 사용자 비율\n- 초기 NPS (Net Promoter Score): 클로즈드 베타/오픈 베타 참여자 대상 NPS (목표: 50점 이상)\n\n---\n---\n\n## 4. 핵심 사용자(Personas)\n1. 김순자(68세) – 은퇴 후 삶을 정리하고 싶은 시니어\n2. 이지훈(42세) – 부모님께 의미 있는 선물을 준비하는 직장인 아들\n3. 박은영(38세) – 퍼스널 브랜딩이 필요한 1인 기업가\n\n|AI 인터뷰|맞춤 질문 생성|사용자 답변 기반 후속 질문 + 사용자가 선택 가능한 시기별/주제별 질문 템플릿 제공 (예: 유년기, 학창시절, 직장생활, 가족 등)|\n|스토리 캡처|대화형 UI|채팅 형식 텍스트 입력 + STT 음성 입력 + STT 결과물 즉시 편집/수정 기능 (음성 인식 오류는 시니어 사용자에게 큰 이탈 요인임)|\n|스토리 캡처|글감 보관함 (메모장)|특정 챕터에 속하지 않는 단편적인 기억(단어, 문장, 에피소드)을 임시 저장하고, 나중에 AI가 챕터 구성 시 활용하도록 제안하는 기능|\n|스토리 캡처|스토리별 이미지 업로드|각 에피소드(스토리 조각)마다 사진 1~2장을 업로드하는 기능. (자서전의 완성도에 필수적이며 MVP에 포함 권장)|\n|스토리 캡처|대화형 UI|채팅 형식 텍스트 입력 + STT 음성 입력 + STT 결과물 즉시 편집/수정 기능 (음성 인식 오류는 시니어 사용자에게 큰 이탈 요인임)|\n|서사 구조|자동 목차/초안 생성|답변을 종합해 챕터 구조·본문 초안 작성 + 생성된 목차/챕터 순서 수동 변경(Drag & Drop) 기능|\n### 5.1 Core Features (1단계 MVP)\n|출판|PDF·eBook·인쇄 파일 생성|원클릭으로 POD 서비스 연동 + 완성 전 '미리보기(Preview)' 기능 (인쇄될 실제 레이아웃 확인)|\n|저장/보안|실시간 자동 저장 + 암호화|PIPA 준수, 데이터 백업 및 복원 정책 (RBAC은 2단계 '협업 모드'와 더 연관성이 높으므로 MVP에서는 백업/보안에 집중)|\n|AI 인터뷰|맞춤 질문 생성|사용자 답변 기반 후속 질문 자동 생성|\n|스토리 캡처|대화형 UI|채팅 형식 텍스트 입력 + STT 음성 입력|\n|서사 구조|자동 목차/초안 생성|답변을 종합해 챕터 구조·본문 초안 작성|\n|편집 지원|실시간 문장 다듬기·문체 제안|LLM으로 문법, 어조, 톤 즉시 개선|\n|출판|PDF·eBook·인쇄 파일 생성|원클릭으로 POD 서비스 연동|\n|저장/보안|실시간 자동 저장 + 암호화|PIPA 준수, RBAC 기반 접근 통제|\n\n### 5.2 Supplementary Features (2단계 이후)\n1. 김순자는 회원가입 후 “새 자서전 시작”을 눌러 제목을 입력한다.\n2. AI 인터뷰어가 첫 질문 “유년 시절에 가장 기억에 남는 순간은?”을 던진다.\n3. 김순자는 음성으로 답변하고, AI가 텍스트로 변환하자 일부 틀린 단어(예: '소풍'이 '속풍'으로 입력됨)를 직접 수정한다.\n4. 5개의 에피소드(스토리 조각)가 모이자, AI가 자동으로 ‘유년기’ 챕터 초안을 생성한다.\n5. 다음 날 김순자가 다시 로그인하자, AI가 \"어제는 유년 시절에 대해 즐겁게 이야기했네요. 오늘은 학창 시절에 대해 이야기해볼까요?\"라며 맥락을 이어간다.\n6. 김순자는 문체를 “따뜻하고 담담하게”로 설정하여 문장 다듬기를 적용한다.\n7. 김순자는 '글감 보관함'에 적어두었던 '첫 월급날의 기억'을 '사회 초년기' 챕터로 이동시킨다.\n8. 진행 현황이 80%가 되면 목표 알림이 팝업되고, ‘완성’ 버튼을 누른다.\n9. 인쇄 전 '미리보기'를 통해 사진 배치와 오탈자를 최종 확인한다.\n10. PDF를 다운로드하고 POD 인쇄를 주문하며, 아들 이지훈에게 PDF 파일을 카카오톡으로 공유한다.\n\n- 공감형 AI 인터뷰: RAG+LLM으로 장기 맥락을 기억하여 ‘적극적 경청’ 경험 제공\n- 비용 우위: 프리미엄 모델 기준 10만 원대 자서전 제작 가능\n- 시니어 친화적 UX/UI: 단순한 '접근성(큰 글꼴)'을 넘어, 시니어의 인지 모델에 맞춘 '과업 중심의 단순한 인터페이스' 제공 (예: 한 화면에 하나의 태스크만 제시)\n- 접근성: 시니어 친화 큰 글꼴, 단순 내비게이션, 웹 브라우저만 필요\n- 신뢰: 한국 PIPA 완전 준수, 동의 대시보드 노출로 투명성 확보\n4. 5개의 에피소드가 모이면 AI가 자동으로 ‘유년기’ 챕터 초안을 생성한다.\n5. 김순자는 문체를 “따뜻하고 담담하게”로 설정하여 문장 다듬기를 적용한다.\n6. 진행 현황이 80%가 되면 목표 알림이 팝업되고, ‘완성’ 버튼을 누른다.\n7. PDF를 다운로드하고 POD 인쇄를 주문한다.\n  • Free: 1개 프로젝트, AI 생성 챕터 최대 3개 (또는 AI 인터뷰 질문 50개) 제한, 스토리 조각 최대 20개 저장 제한, PDF/eBook 생성 불가, 광고 배너\n---\n\n## 7. 경쟁 우위\n- 공감형 AI 인터뷰: RAG+LLM으로 장기 맥락을 기억하여 ‘적극적 경청’ 경험 제공\n- 비용 우위: 프리미엄 모델 기준 10만 원대 자서전 제작 가능\n- 접근성: 시니어 친화 큰 글꼴, 단순 내비게이션, 웹 브라우저만 필요\n- 신뢰: 한국 PIPA 완전 준수, 동의 대시보드 노출로 투명성 확보\n\n---\n\n## 8. 비즈니스 모델\n- Freemium\n  • Free: 1개 프로젝트, 질문/챕터 제한, 광고 배너\n  • Premium 구독(연 99,000원): 무제한 AI 사용·저장, PDF/eBook, 인쇄 1권 쿠폰 포함\n  • 추가 인쇄본, 전문 편집 서비스는 건별 과금\n\n---\n\n3. 개인정보 우려 → 데이터 한국 리전 저장, 동의 관리 UI\n4. 초기 동기 부여 실패 (Low Activation/Motivation)\n    - 내용: 사용자가 AI와의 대화를 어색해하거나, '무슨 말부터 해야 할지' 몰라 초기 몇 번의 시도 후 이탈함.\n    - 대응:\n        1. 온보딩 시 'AI 인터뷰어'의 페르소나(예: 따뜻한 손자/손녀)를 강조하고, \"정답은 없으니 편하게 말씀하세요\"라는 가이드 강화.\n- 상기 PRD에 대한 피드백 후 개발 킥오프 진행 여부 결정\n\n\n\n## 10. 리스크 및 대응\n1. LLM API 비용 변동 → 하이브리드 모델(저가+프리미엄) 분산 사용\n2. 시니어 UX 난이도 → 사용자 테스트 반복, 버튼·글꼴 크기 표준화\n3. 개인정보 우려 → 데이터 한국 리전 저장, 동의 관리 UI\n\n---\n\n## 11. 승인 요청\n- 상기 PRD에 대한 피드백 후 개발 킥오프 진행 여부 결정\n\n---\n\n## 12. 가정 및 제약 사항 (Assumptions & Constraints)\n\n**가정 (Assumptions)**\n1. 시니어 사용자는 자신의 삶을 '기록'하려는 본질적인 욕구가 있으며, 'AI'에 대한 거부감보다 '저렴한 비용'과 '편의성'이라는 가치를 더 크게 느낄 것이다.\n2. 구매자(자녀 세대)는 '물리적인 책' 형태의 선물을 '의미 있다'고 판단하며, 연 99,000원의 비용을 기꺼이 지불할 것이다.\n3. STT 기술은 시니어의 발화(느린 속도, 방언, 특정 어휘)를 85% 이상 정확도로 인식할 수 있다.\n4. 사용자는 AI가 생성한 '초안'이 완벽하지 않더라도, '시작점'을 제공받는 것 자체에 큰 가치를 느낄 것이다.\n\n**제약 (Constraints)**\n1. MVP는 웹 기반(데스크톱/태블릿 우선)으로 개발하며, 모바일 앱은 고려하지 않는다. (모바일은 반응형 웹 지원)\n2. 모든 데이터는 한국 PIPA 및 관련 법규를 준수하기 위해 국내 리전(Region)에 저장/처리해야 한다.\n3. 핵심 LLM API는 외부(예: OpenAI, Google, Naver)의 상용 API를 우선 사용하며, 자체 모델 구축은 2단계 이후에 고려한다.\n        3. 매우 쉽고 구체적인 첫 질문 템플릿 제공 (예: \"태어나신 곳의 풍경은 어땠나요?\", \"가장 좋아했던 음식은 무엇인가요?\").\n5. STT/LLM의 부정확성 및 할루시네이션 (Accuracy Risk)\n    - 내용: 음성 인식이 자주 틀리거나(특히 사투리, 고유명사), AI가 사용자의 기억을 요약/편집하는 과정에서 사실 관계를 왜곡(환각)하여 신뢰를 상실함.\n    - 대응:\n        1. STT 결과물에 대한 '즉각적인 수정' UI를 가장 잘 보이는 곳에 배치.\n        2. LLM 프롬프트 엔지니어링 시 '창작'이 아닌 '정리', '윤문', '구조화'에만 집중하도록 엄격히 제한.\n        3. RAG 적용 시, 사용자의 '원본 텍스트(STT 수정본)'를 가장 강력한 소스(Source of Truth)로 사용하여 AI가 임의로 내용을 변경하지 못하게 함.\n| 분기 | 목표 | 세부 내용 |\n|---|---|---|\n|Q1|MVP 개발 & 클로즈드 베타|Core 5개 기능 완성, 50명 테스트|\n|Q2|오픈 베타 + 결제연동|프리미엄 결제, PDF 생성, UX 개선|\n|Q3|POD & 사진캡션 기능|인쇄 파트너 API, AI 사진 배치|\n|Q4|협업 모드·알림|가족 초대, 진행 타임라인, 모바일 반응형 고도화|\n\n---",
      "writedAt": "2025-10-25T11:38:34.666Z"
    },
    {
      "type": "architecture",
      "content": "제공해주신 TRD(Technical Requirements Document) 초안을 바탕으로, 프로젝트 \"ECHO\"의 성공적인 개발을 위해 각 항목을 더 구체화하고 누락된 핵심 섹션을 추가하여 완성도를 높였습니다.\n\n특히 **AI 기능의 구체적인 구현 방식, 데이터베이스 스키마, 보안(RLS), 그리고 시니어 사용자를 위한 접근성(NFRs)** 부분을 중점적으로 보강했습니다.\n\n-----\n\n# Technical Requirements Document (TRD)\n\n## (코드명: ECHO)\n\n## 1\\. Executive Technical Summary\n\n**Project Overview:** LLM 기반 AI 자서전 작성 플랫폼 \"ECHO\"는 시니어 및 가족이 자신의 삶의 이야기를 체계적으로 기록하고, AI의 인터뷰 및 자동 서사 구조화 기능을 통해 각 개인의 인생사를 깊이 있게 탐구할 수 있도록 지원합니다. 플랫폼은 챕터별 작성 가이드, AI 질문 자동 생성, 맞춤형 편집 피드백, 자동 목차 및 타임라인 생성, 표지/사진/삽화 AI 추천 등 구체적인 기능을 제공하여, 사용자는 손쉽게 고품질 자서전을 완성 및 출판할 수 있습니다. 또한, 웹 접근성 표준을 준수한 UI/UX를 통해 시니어 사용자의 접근성과 사용 편의성을 극대화합니다.\n\n**Core Technology Stack:** Next.js 기반 SSR/SSG, Supabase(PostgreSQL) 데이터베이스 및 인증, OpenAI GPT API 기반 인터뷰 및 편집 지원, TailwindCSS를 통한 반응형 UI, ImageKit을 활용한 이미지 최적화 및 CDN 제공, Vercel 기반 무중단 배포, Sentry를 이용한 실시간 에러 모니터링, LaunchDarkly 기반 기능 플래그 관리 등 구체적인 기술 스택을 사용합니다.\n\n**Key Technical Objectives:**\n\n  * **Performance:** 95% 타일 기준 페이지 최초 로딩 2초 이내, AI 인터뷰 응답 스트리밍 시작 1.5초 이내, 이미지 최적화 처리 1초 이내.\n  * **Scalability:** 멀티테넌시(Multi-tenancy) 지원, 10,000명 동시 접속 시 서버리스 함수 및 DB 자동 스케일링, AI 인터뷰(Streaming)와 챕터 생성(Batch) 작업 큐 분리.\n  * **Reliability:** 99.9% 시스템 가용성, Supabase Point-in-Time Recovery(PITR)를 통한 실시간 백업 및 주 1회 전체 스냅샷 백업.\n  * **Security:** 사용자 데이터 암호화 저장, 개인정보(PII) 분리 보관, Supabase RLS(Row Level Security)를 통한 데이터 접근권한 최소화, OWASP Top 10 취약점 대응.\n\n**Critical Technical Assumptions:**\n\n  * OpenAI API, Supabase, Vercel 등 핵심 외부 서비스의 SLA(Service Level Agreement)가 99.9% 수준으로 준수됨.\n  * 모든 사용자 데이터는 국내법(PIPA)을 준수하여 처리되며, 사용자 동의 관리 프로세스가 명확히 구현됨.\n  * 시니어 사용자의 웹 접근성(WCAG 2.1 Level AA) 기준을 완전 준수함.\n\n-----\n\n## 2\\. Tech Stack\n\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n|---|---|---|\n| **Platform (Frontend/Backend)** | **Next.js 14+ (App Router)** | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG)을 지원하여 초기 로딩 속도 최적화(SEO 유리). React 기반 컴포넌트 재사용성. API Routes (Serverless Functions)를 통해 별도 백엔드 서버 없이 비즈니스 로직 처리. |\n| **Database & Auth** | **Supabase (PostgreSQL)** | 관리형 PostgreSQL DB. 내장된 인증(Auth), 스토리지(Storage), 실시간(Realtime) 기능을 제공하여 MVP 개발 속도 극대화. **`pg_vector`** 확장을 통한 벡터 데이터베이스 기능(RAG 구현용) 지원. |\n| **AI (LLM)** | **OpenAI GPT-4o / GPT-4 Turbo** | RAG 기반 '공감형 인터뷰' 및 '초안 생성'에 필요한 고품질 언어 모델. API 응답 속도와 비용 효율성을 고려하여 모델 선정. (GPT-3.5-Turbo는 단순 윤문 기능에 활용) |\n| **AI (STT)** | **Google Speech-to-Text API** (또는 Naver Clova) | 시니어 사용자의 음성 입력을 텍스트로 변환. 한국어 인식률, 특히 방언 및 고유명사 인식률이 높은 서비스 선정. (MVP 단계에서는 브라우저 내장 Web Speech API로 테스트) |\n| **Styling & UI** | **TailwindCSS + shadcn/ui** | 유틸리티 우선 CSS 프레임워크로 신속한 UI 개발 및 일관성 유지. `shadcn/ui`를 통해 접근성(a11y)이 확보된 고품질 컴포넌트(버튼, 폼 등) 즉시 활용. |\n| **Rich Text Editor** | **Tiptap (or Lexical)** | 자서전 본문 작성을 위한 블록 기반 리치 텍스트 에디터. 확장성이 뛰어나며, 실시간 문법/문체 교정(AI 연동) 기능 구현에 용이. |\n| **Image Optimization** | **ImageKit.io** | 사용자가 업로드한 원본 이미지를 실시간으로 리사이징, 포맷 변환(WebP), 최적화하여 CDN으로 제공. 자서전 이미지 로딩 속도 및 LCP 개선에 필수적. |\n| **Deployment & Hosting** | **Vercel** | Next.js에 최적화된 호스팅 플랫폼. Git 연동(GitHub/GitLab)을 통한 자동 CI/CD, 무중단 배포, 글로벌 CDN, Serverless Function 환경 기본 제공. |\n| **Monitoring** | **Sentry** | 프론트엔드 및 백엔드(API Routes)에서 발생하는 에러를 실시간으로 추적하고 알림. 사용자 경험에 영향을 미치는 버그 조기 발견 및 대응. |\n| **Feature Flags** | **LaunchDarkly (or Vercel Flags)** | 신규 기능(예: AI 사진 배치)을 특정 사용자 그룹(베타 테스터)에게만 선별적으로 배포(Canary) 및 A/B 테스트. 리스크 관리 및 점진적 롤아웃. |\n| **State Management** | **Zustand (or Jotai)** | React의 복잡한 상태(예: 사용자 인증 상태, 에디터 내용)를 단순하고 효율적으로 관리. Boilerplate가 적고 Next.js App Router와 호환성이 높음. |\n\n-----\n\n## 3\\. System Architecture (High-Level)\n\n본 시스템은 **Vercel 기반의 서버리스 아키텍처**를 채택합니다.\n\n1.  **Client (User):** 사용자는 웹 브라우저(PC/Tablet)를 통해 Next.js 애플리케이션에 접속합니다.\n2.  **Edge Network (Vercel):** Next.js의 정적 에셋(JS, CSS)과 사전 렌더링된 페이지(SSR/SSG)가 Vercel CDN을 통해 사용자에게 빠르게 전송됩니다.\n3.  **Application Logic (Vercel Functions):**\n      * AI 인터뷰, 챕터 생성, STT 변환 등 모든 동적 로직은 Next.js API Routes (Serverless Functions)에서 처리됩니다.\n      * 이 함수들은 필요시 외부 API(OpenAI, ImageKit, Google STT)를 호출합니다.\n4.  **Data & Auth (Supabase):**\n      * 모든 사용자 데이터(프로젝트, 스토리 조각, 챕터)는 Supabase PostgreSQL DB에 저장됩니다.\n      * 인증은 Supabase Auth를 통해 JWT 기반으로 처리됩니다.\n      * 업로드된 이미지/음성 파일은 Supabase Storage 또는 ImageKit에 저장됩니다.\n\n<!-- end list -->\n\n```plaintext\n[User (Browser)] <--> [Vercel Edge Network (Next.js Frontend)]\n       |\n       | (API Calls)\n       v\n[Vercel Serverless Functions (Next.js API Routes)]\n       |\n       +--- (Auth/Data/Vector) --> [Supabase (Postgres, Auth, pg_vector)]\n       |\n       +--- (LLM Calls) ---------> [OpenAI API (GPT-4o)]\n       |\n       +--- (Media) -------------> [ImageKit.io (CDN, Optimization)]\n       |\n       +--- (Error Logs) --------> [Sentry]\n```\n\n-----\n\n## 4\\. Core Feature Technical Specifications\n\n### 4.1. 공감형 AI 인터뷰 (RAG + Streaming)\n\n  * **목표:** 사용자의 이전 답변 맥락을 기억하고 자연스러운 후속 질문을 생성.\n  * **기술:** RAG (Retrieval-Augmented Generation) + `pg_vector` + Streaming.\n  * **프로세스:**\n    1.  **[Embedding]** 사용자가 '스토리 조각(답변)'을 저장할 때마다, 해당 텍스트를 임베딩하여 Supabase `pg_vector`에 저장합니다. (`fragment_embeddings` 테이블)\n    2.  **[Retrieval]** 사용자가 새 질문을 요청하거나 답변을 입력하면, 해당 내용을 쿼리로 사용하여 `pg_vector`에서 가장 관련성 높은 과거 대화(스토리 조각) N개를 검색합니다.\n    3.  **[Augmentation]** 검색된 맥락(과거 대화)과 현재 대화, 그리고 \"당신은 따뜻한 인터뷰어입니다...\"라는 시스템 프롬프트를 조합하여 OpenAI API에 전달합니다.\n    4.  **[Generation & Streaming]** OpenAI API의 응답을 `stream`으로 받아, 사용자가 즉각적으로 AI의 답변(질문)을 볼 수 있도록 UI에 실시간으로 렌더링합니다. (Vercel AI SDK 활용)\n\n### 4.2. 스토리 캡처 (STT & Rich Text Editor)\n\n  * **목표:** 음성 입력을 텍스트로 변환하고, 이를 즉시 편집할 수 있는 환경 제공.\n  * **기술:** Google STT API (or Web Speech API) + Tiptap Editor.\n  * **프로세스:**\n    1.  사용자가 '음성 녹음' 버튼을 누르고 말하면, 오디오 데이터가 서버리스 함수로 전송됩니다.\n    2.  서버리스 함수는 이 오디오를 STT API로 전달하여 텍스트 변환 결과를 받습니다. (장문 인식 모드 활성화)\n    3.  변환된 텍스트는 Tiptap 에디터의 새 블록(Paragraph)으로 즉시 삽입됩니다.\n    4.  사용자는 Tiptap 에디터에서 STT 오류를 실시간으로 수정하고, 문장(AI 윤문) 또는 단락(문체 변경) 단위로 AI 편집 지원을 요청할 수 있습니다.\n\n### 4.3. 자동 서사 구조화 (Async Batch Job)\n\n  * **목표:** 수집된 '스토리 조각'들을 바탕으로 자서전 목차와 챕터별 초안을 생성.\n  * **기술:** Vercel Cron Jobs (or Supabase PG Cron) + OpenAI API (Batch).\n  * **프로세스:**\n    1.  사용자가 '초안 생성하기' 버튼을 클릭합니다.\n    2.  이는 특정 `project_id`에 대한 '초안 생성' 작업을 비동기 큐(Vercel KV 또는 Supabase 테이블)에 등록합니다. (사용자에게는 \"초안 생성 중입니다...\" 알림 표시)\n    3.  예약된 Cron Job(예: 1분마다 실행)이 큐를 확인하고 작업을 처리합니다.\n    4.  작업 로직:\n        a. 해당 `project_id`의 모든 '스토리 조각'을 불러옵니다.\n        b. OpenAI API에 \"다음 텍스트들을 유년기, 청년기... 등 시간순으로 분류하고, 각 챕터의 제목을 정하고, 내용을 서사적으로 재구성해줘\"라는 복잡한 프롬프트를 전송합니다.\n        c. 반환된 텍스트(JSON 또는 Markdown 형식)를 파싱하여 `chapters` 테이블에 저장합니다.\n    5.  작업 완료 시 사용자에게 웹 푸시 또는 이메일로 알림을 보냅니다.\n\n### 4.4. 출판 (PDF/eBook 생성)\n\n  * **목표:** 완성된 자서전 콘텐츠를 인쇄 가능한 PDF 파일로 변환.\n  * **기술:** `Puppeteer` (Serverless Function) 또는 서드파티 API (`Gotenberg`, `PDFShift`).\n  * **프로세스:**\n    1.  사용자가 'PDF 다운로드'를 요청합니다.\n    2.  자서전의 모든 챕터 콘텐츠(HTML)와 CSS(인쇄용 스타일)를 결합합니다.\n    3.  `Puppeteer` (Headless Chrome)를 실행하는 전용 서버리스 함수를 호출합니다. (메모리 증설 필요. 예: Vercel Pro Plan)\n    4.  `Puppeteer`가 해당 HTML/CSS를 로드하여 PDF 파일로 렌더링합니다.\n    5.  생성된 PDF를 Supabase Storage에 업로드하고, 사용자에게 다운로드 URL을 제공합니다.\n\n-----\n\n## 5\\. Data Management & Schema\n\n  * **DB:** Supabase (PostgreSQL)\n  * **핵심 원칙:** PIPA 준수를 위해 모든 데이터는 서울 리전(ap-northeast-2)에 저장.\n\n### 5.1. Logical Database Schema (Key Tables)\n\n  * **`users`** (Supabase Auth 제공)\n      * `id` (uuid, PK), `email`, `created_at`, `raw_user_meta_data` (이름 등)\n  * **`projects`** (자서전 프로젝트)\n      * `id` (uuid, PK), `user_id` (uuid, FK, RLS 키), `title` (text), `status` (enum: drafting, completed), `created_at`\n  * **`story_fragments`** (AI 인터뷰로 수집된 개별 에피소드/답변)\n      * `id` (uuid, PK), `project_id` (uuid, FK), `user_id` (uuid, FK, RLS 키), `content_raw` (text, 원본 답변), `audio_url` (text, nullable), `created_at` (timestamp)\n  * **`fragment_embeddings`** (RAG용 벡터 데이터)\n      * `id` (uuid, PK), `fragment_id` (uuid, FK), `user_id` (uuid, FK, RLS 키), `content_embedding` (vector, 1536 dims)\n  * **`chapters`** (AI가 생성/편집한 챕터)\n      * `id` (uuid, PK), `project_id` (uuid, FK), `user_id` (uuid, FK, RLS 키), `title` (text), `content_draft` (jsonb, Tiptap JSON 형식), `order` (int)\n  * **`images`** (사용자 업로드 이미지)\n      * `id` (uuid, PK), `project_id` (uuid, FK), `user_id` (uuid, FK, RLS 키), `imagekit_url` (text), `caption` (text)\n\n-----\n\n## 6\\. Security & Compliance\n\n1.  **Authentication:** Supabase Auth를 통해 JWT(JSON Web Token) 기반 인증 시행. 모든 API 요청은 유효한 JWT를 포함해야 함.\n2.  **Authorization (RLS):** **Supabase의 RLS(Row Level Security)를 모든 핵심 테이블에 적용.** 사용자는 자신의 `user_id`와 일치하는 데이터(프로젝트, 챕터, 스토리 조각 등)에만 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 권한을 가짐. 이는 멀티테넌시 보안의 핵심임.\n3.  **Data Encryption:** 모든 데이터는 전송 중(SSL/TLS) 및 저장 시(At-rest encryption, Supabase 제공) 암호화됨.\n4.  **PIPA (개인정보보호법):**\n      * 모든 사용자 데이터는 Supabase 서울 리전에 저장.\n      * 회원가입 시 개인정보 수집/이용 동의, AI 처리 동의 명시적 수신.\n      * 사용자 탈퇴 시 모든 관련 데이터(프로젝트, 챕터, 이미지 등) 즉시 또는 배치로 완전 삭제(Hard Delete) 처리.\n5.  **OWASP Top 10:**\n      * **Injection:** Supabase 클라이언트 라이브러리 사용으로 SQL Injection 방지.\n      * **Broken Access Control:** RLS(상기 2번)를 통해 철저히 방어.\n      * **XSS (Cross-Site Scripting):** Next.js(React)의 기본 이스케이핑 및 Tiptap 에디터의 콘텐츠 정제(Sanitization)를 통해 방어.\n\n-----\n\n## 7\\. Deployment & DevOps (CI/CD)\n\n  * **Repository:** GitHub (Private)\n  * **CI/CD Pipeline:** Vercel\n  * **환경 (Environments):**\n    1.  **`development` (Local):** 로컬 개발 환경 (Supabase CLI 연동).\n    2.  **`staging` (Preview):** `dev` 또는 `feature/*` 브랜치 PUSH 시 Vercel이 자동 생성하는 프리뷰 URL. QA팀 및 기획자 리뷰용.\n    3.  **`production`:** `main` 브랜치 PUSH(또는 PR Merge) 시 Vercel이 자동 빌드 및 프로덕션 배포.\n  * **Database Migrations:** Supabase CLI를 사용하여 마이그레이션 파일(`schema.sql`)을 관리하고, Vercel 배포 파이프라인과 연동하여 프로덕션 DB 스키마를 안전하게 변경.\n  * **Monitoring:** Sentry를 Vercel 프로젝트에 연동하여 에러 발생 시 즉시 Slack/Email 알림 수신.\n\n-----\n\n## 8\\. Non-Functional Requirements (NFRs)\n\n1.  **Accessibility (A11y):**\n      * **목표:** **WCAG 2.1 Level AA 표준 준수.** (시니어 사용자를 위한 필수 요구사항)\n      * **구현:**\n          * 모든 인터랙티브 요소(버튼, 링크)에 대한 키보드 접근성(Focus a11y) 보장.\n          * 시맨틱 HTML (`<nav>`, `<main>`, `<button>`) 사용.\n          * 최소 4.5:1 이상의 텍스트 명암비 준수 (Tailwind 색상 팔레트 정의).\n          * 기본 글꼴 크기 `16px` 이상, 사용자가 브라우저에서 200%까지 확대해도 레이아웃이 깨지지 않아야 함.\n          * 모든 이미지에 `alt` 텍스트 제공.\n2.  **Performance:** (1. Executive Summary 참조)\n      * Next.js의 ISR(Incremental Static Regeneration)을 활용하여 자주 변경되지 않는 페이지(예: 소개 페이지)는 정적 캐시.\n      * `ImageKit`을 통한 이미지 최적화 및 WebP 포맷 우선 제공.\n3.  **Scalability:**\n      * Vercel 서버리스 함수와 Supabase DB는 사용량에 따라 자동 스케일링됨.\n      * AI 초안 생성 등 리소스 집약적 작업은 비동기 처리하여 메인 스레드를 차단하지 않음.\n4.  **Usability (UX for Seniors):**\n      * '다음 단계'가 명확한 단순한 UI 플로우.\n      * 터치 영역(버튼 크기)은 최소 `44x44px` 이상 (Fitts's Law 적용).\n      * 아이콘과 함께 명확한 텍스트 레이블 병기.\n      * 모든 작업은 '실시간 자동 저장'되어 사용자가 실수로 페이지를 닫아도 데이터가 유실되지 않음. (Zustand 상태를 LocalStorage에 연동 또는 Debounce를 통한 자동 API 저장)",
      "writedAt": "2025-10-25T11:38:34.666Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n\n-----\n\n# ECHO Project - Code Guidelines\n\n## 1\\. Project Overview\n\nECHO 프로젝트는 시니어와 그 가족들이 자신의 삶의 이야기를 기록하고 AI의 도움을 받아 고품질의 자서전을 만들 수 있도록 지원하는 LLM 기반 AI 자서전 플랫폼입니다. Next.js, Supabase, OpenAI API, TailwindCSS를 핵심 기술로 활용합니다. 주요 아키텍처는 성능을 위한 서버 컴포넌트 렌더링, 강력한 인증 시스템, AI 기반 콘텐츠 생성, 그리고 반응형 및 접근성 높은 UI를 특징으로 합니다.\n\n## 2\\. Core Principles\n\n  * **유지보수성 (Maintainability)**: 이해하고, 수정하고, 디버깅하기 쉬운 코드를 작성합니다.\n  * **가독성 (Readability)**: 코드는 명확하고 간결하며, 잘 문서화되어야 합니다.\n  * **테스트 용이성 (Testability)**: 쉽게 테스트하고 검증할 수 있도록 코드를 설계합니다.\n  * **성능 (Performance)**: 속도와 효율성을 위해 코드를 최적화합니다.\n  * **보안 (Security)**: 사용자 데이터 보호를 위해 보안 코딩 관행을 최우선으로 합니다.\n\n## 3\\. Language-Specific Guidelines\n\n### 3.1. TypeScript (ECMAScript Next)\n\n  * **프로젝트 언어**: 본 프로젝트는 **TypeScript** 사용을 **강력히 권장**합니다. 타입 안정성을 통해 런타임 에러를 줄이고, 코드 자동 완성을 강화하며, 유지보수성을 크게 향상시킵니다.\n  * **파일 조직 및 디렉터리 구조:** (Next.js App Router 기준)\n      * `app/`: App Router 기반 라우팅 및 페이지 컴포넌트.\n      * `components/`: 재사용 가능한 UI 컴포넌트 (프레젠테이션 로직).\n          * `ui/`: (shadcn/ui와 유사) 버튼, 인풋 등 원자적(Atomic) 컴포넌트.\n          * `common/`: 여러 페이지에서 사용되는 공통 컴포넌트 (예: `Header`, `Footer`).\n          * `features/`: 특정 도메인/기능과 관련된 복합 컴포넌트 (예: `AutobiographyEditor`).\n      * `lib/`: 핵심 비즈니스 로직, 외부 API 클라이언트, 유틸리티.\n          * `supabaseClient.ts`: Supabase 클라이언트 인스턴스 (서버/클라이언트 구분).\n          * `openaiClient.ts`: OpenAI API 클라이언트 인스턴스.\n          * `utils.ts`: 순수 헬퍼 함수 (예: `formatDate`, `cn` - `clsx` + `tailwind-merge`).\n          * `db.ts`: (선택적) 데이터베이스 쿼리 로직 추상화.\n      * `hooks/`: 커스텀 React 훅 (예: `useAuth`).\n      * `types/`: 전역 또는 공유 TypeScript 타입 정의 (예: `supabase.types.ts`).\n      * `app/api/`: API 라우트 핸들러.\n  * **Import/Dependency 관리:**\n      * 내부 모듈 import 시 절대 경로 사용 (`@/components/Button` vs `../../components/Button`). `tsconfig.json`의 `paths` 별칭을 구성합니다.\n      * 의존성 설치는 `pnpm install` 또는 `npm install` 사용. `package.json`에 버전을 명시합니다.\n      * **Import 순서**: 1) React/Next.js 2) 외부 라이브러리 3) 내부 절대 경로 (`@/`) 4) 상대 경로 (`./`, `../`).\n  * **에러 핸들링 패턴:**\n      * 비동기 작업(API 호출) 시 `try...catch` 블록을 사용합니다.\n      * React 컴포넌트의 오류 처리를 위해 **Error Boundaries** (`error.tsx`)를 적극 활용합니다.\n      * 프로덕션 환경에서는 `console.error` 대신 **Sentry**와 같은 중앙 집중식 로깅 서비스에 에러를 전송합니다.\n\n<!-- end list -->\n\n```typescript\n// MUST: API 호출 시 try...catch 및 Sentry 사용\nimport { Sentry } from '@/lib/sentry'; // 가상 Sentry 클라이언트\n\nasync function fetchData(userId: string) {\n  try {\n    const response = await fetch(`/api/user/${userId}`);\n    if (!response.ok) {\n      // 4xx, 5xx 에러를 명시적으로 throw\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    if (process.env.NODE_ENV === 'development') {\n      console.error(\"Error fetching data:\", error);\n    } else {\n      // 프로덕션에서는 Sentry로 에러 리포트\n      Sentry.captureException(error, { tags: { context: \"fetchData\" } });\n    }\n    // 사용자에게 친화적인 에러 메시지 반환 또는 null\n    return null;\n  }\n}\n\n// MUST NOT: 에러 무시\nasync function fetchDataBad() {\n  // 네트워크 에러, 404, 500 등 예외 상황 처리 불가\n  const response = await fetch('/api/data'); \n  const data = await response.json();\n  return data;\n}\n// Explanation: 잠재적인 네트워크 오류나 유효하지 않은 응답을 처리하지 않아 앱이 비정상 종료될 수 있습니다.\n```\n\n### 3.2. Next.js (App Router)\n\n  * **파일 조직:** `app/` 디렉터리 기반 라우팅 시스템을 따릅니다.\n      * `app/layout.tsx`: 루트 레이아웃 (필수).\n      * `app/page.tsx`: 홈페이지 (`/`).\n      * `app/dashboard/page.tsx`: `/dashboard` 라우트.\n      * `app/loading.tsx`: 기본 로딩 UI.\n      * `app/error.tsx`: 기본 에러 바운더리.\n  * **API Routes:** `app/api/` 디렉터리 내 `route.ts` (또는 `.js`) 파일을 사용합니다.\n  * **데이터 페칭:**\n      * **서버 컴포넌트 (기본):** `async` 함수로 컴포넌트를 선언하고 `fetch`, `await`를 직접 사용합니다. (SSG, SSR, ISR 동작 제어는 `fetch`의 `cache` 옵션 또는 `revalidate` 옵션으로 처리)\n      * **클라이언트 컴포넌트 (`'use client'`):** `useEffect` 또는 `SWR`, `React Query`를 사용하여 클라이언트 사이드에서 데이터를 페칭합니다.\n      * **Server Actions:** 폼(Form) 제출 및 데이터 변경(Mutation)에 `Server Actions` 사용을 적극 권장합니다. (클라이언트 JS 없이 폼 처리 가능)\n\n<!-- end list -->\n\n```typescript\n// MUST: 서버 컴포넌트에서의 데이터 페칭 (App Router)\n// app/dashboard/page.tsx\nimport { createServerComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { cookies } from 'next/headers';\n\n// 이 컴포넌트는 기본적으로 서버 컴포넌트입니다.\nasync function getDashboardData() {\n  const supabase = createServerComponentClient({ cookies });\n  const { data, error } = await supabase.from('projects').select('*');\n  if (error) throw new Error('Failed to fetch data');\n  return data;\n}\n\nexport default async function DashboardPage() {\n  const data = await getDashboardData(); // 서버에서 직접 데이터 페칭\n\n  return (\n    <div>\n      {data.map(project => <div key={project.id}>{project.title}</div>)}\n    </div>\n  );\n}\n\n// MUST NOT: 서버 컴포넌트에서 useEffect 사용\n// app/some-page/page.tsx (잘못된 예시)\n// import { useEffect, useState } from 'react'; // 서버 컴포넌트에서 이 훅들은 동작하지 않습니다.\n\nexport default function MyPage() {\n  // const [data, setData] = useState(null); // 에러 발생\n\n  // useEffect(() => { ... }, []); // 에러 발생\n\n  return (\n    // ...\n  );\n}\n// Explanation: 서버 컴포넌트는 서버에서만 렌더링되므로 `useState`, `useEffect` 같은 클라이언트 훅을 사용할 수 없습니다.\n// 클라이언트 훅이 필요하면 파일 상단에 'use client'를 선언해야 합니다.\n```\n\n### 3.3. Supabase\n\n  * **클라이언트 구분:**\n      * **서버 측 (Server Components, API Routes, Server Actions):** `@supabase/auth-helpers-nextjs`의 `createServerComponentClient`, `createRouteHandlerClient` 등을 사용하여 **사용자 세션**을 안전하게 처리하거나, **`service_role` 키**를 사용하여 RLS를 우회하는 관리자 작업을 수행합니다.\n      * **클라이언트 측 (`'use client'`):** `createClientComponentClient`를 사용합니다.\n  * **보안:**\n      * **RLS (Row Level Security):** **필수.** 모든 테이블에 RLS 정책을 구현하여 사용자가 자신의 데이터에만 접근할 수 있도록 제어합니다.\n      * **`service_role` 키 노출 금지:** `service_role` 키는 **절대** 클라이언트 코드나 `.env.local` (NEXT\\_PUBLIC\\_ 접두사)에 노출되어서는 안 됩니다. 서버 환경 변수(예: Vercel 환경 변수)로만 관리합니다.\n  * **환경 변수:** Supabase URL과 `anon` 키는 `NEXT_PUBLIC_` 접두사를 붙여 `.env.local`에 저장하고, `service_role` 키는 접두사 없이 저장합니다.\n\n<!-- end list -->\n\n```typescript\n// MUST: 서버 API 라우트에서 Supabase 사용 (Route Handler)\n// app/api/projects/route.ts\nimport { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';\nimport { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n  const supabase = createRouteHandlerClient({ cookies });\n  \n  // RLS 정책에 따라 현재 로그인된 사용자의 프로젝트만 가져옴\n  const { data, error } = await supabase.from('projects').select('*');\n\n  if (error) {\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n\n  return NextResponse.json(data);\n}\n\n// MUST NOT: 클라이언트에서 'service_role' 키 사용\n// app/some-component/page.tsx ('use client') - (절대 금지)\nimport { createClient } from '@supabase/supabase-js';\n\n// const supabase = createClient(url, process.env.SUPABASE_SERVICE_ROLE_KEY); // (X)\n// Explanation: 'service_role' 키는 RLS를 우회하므로 클라이언트에 노출되면 모든 데이터를 탈취당할 수 있습니다.\n```\n\n### 3.4. OpenAI API\n\n  * **API 키 관리:** OpenAI API 키는 서버 환경 변수 (`OPENAI_API_KEY`)로만 저장합니다. **절대** Git 리포지토리나 클라이언트 코드에 커밋하지 않습니다.\n  * **API 호출 위치:** 모든 OpenAI API 호출은 \\*\\*서버(API Routes 또는 Server Actions)\\*\\*를 통해서만 이루어져야 합니다. 클라이언트가 직접 OpenAI API를 호출하지 않도록 합니다.\n  * **최신 모델 사용:** `openai.completions.create` (레거시) 대신 \\*\\*`openai.chat.completions.create`\\*\\*와 `gpt-4o` 또는 `gpt-4-turbo` 같은 최신 챗 모델 사용을 권장합니다.\n  * **스트리밍 (Streaming):** AI 인터뷰 기능의 응답성 향상을 위해 **스트리밍 응답**을 사용합니다. (Vercel AI SDK 사용 권장)\n  * **비용 최적화 및 속도 제한:** API 사용량을 모니터링하고, 불필요한 호출을 줄이도록 프롬프트를 최적화합니다. 또한, 서버 API 라우트에 **속도 제한(Rate Limiting)**(예: `@upstash/ratelimit`)을 구현하여 어뷰징을 방지합니다.\n\n<!-- end list -->\n\n```typescript\n// MUST: Chat Completions API 및 서버사이드 호출\n// app/api/generate-chapter/route.ts\nimport OpenAI from 'openai';\nimport { NextResponse } from 'next/server';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY, // 서버 환경 변수\n});\n\nexport async function POST(request: Request) {\n  const { prompt } = await request.json();\n\n  if (!prompt) {\n    return NextResponse.json({ error: 'Prompt is required' }, { status: 400 });\n  }\n\n  try {\n    const chatCompletion = await openai.chat.completions.create({\n      model: 'gpt-4o', // 최신 챗 모델 사용\n      messages: [\n        { role: 'system', content: 'You are a helpful autobiography assistant.' },\n        { role: 'user', content: prompt }\n      ],\n      max_tokens: 500,\n    });\n    \n    const text = chatCompletion.choices[0].message.content;\n    return NextResponse.json({ text });\n\n  } catch (error) {\n    console.error(\"Error calling OpenAI API:\", error);\n    return NextResponse.json({ error: 'Failed to generate text' }, { status: 500 });\n  }\n}\n\n// MUST NOT: 레거시 API 사용 또는 클라이언트에서 키 사용\n// const openai = new OpenAI({ apiKey: 'sk-...' }); // (X)\n// const completion = await openai.completions.create({ ... }); // (X)\n// Explanation: API 키 하드코딩은 심각한 보안 위험이며, 레거시 API는 성능 및 기능 면에서 최신 챗 모델보다 떨어집니다.\n```\n\n### 3.5. TailwindCSS\n\n  * **설정:** `tailwind.config.ts` 파일을 프로젝트 디자인 시스템(색상, 글꼴, 간격)에 맞게 커스터마이징합니다.\n  * **유틸리티 클래스:** 스타일링은 유틸리티 클래스 사용을 원칙으로 합니다. `@apply`를 사용한 커스텀 CSS 작성은 최소화합니다.\n  * **조건부 클래스:** `clsx`와 `tailwind-merge` 유틸리티 라이브러리 (보통 `cn` 헬퍼 함수로 결합)를 사용하여 조건부 클래스를 명확하고 안전하게 관리합니다.\n  * **컴포넌트 추출:** 반복되는 유틸리티 클래스 패턴은 재사용 가능한 React 컴포넌트(예: `Button`, `Card`)로 추출합니다.\n\n<!-- end list -->\n\n```tsx\n// MUST: cn 헬퍼 함수와 유틸리티 클래스 사용\nimport { cn } from '@/lib/utils';\n\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: 'primary' | 'secondary';\n}\n\nfunction Button({ className, variant = 'primary', ...props }: ButtonProps) {\n  return (\n    <button\n      className={cn(\n        'font-bold py-2 px-4 rounded',\n        {\n          'bg-blue-500 hover:bg-blue-700 text-white': variant === 'primary',\n          'bg-gray-200 hover:bg-gray-300 text-gray-800': variant === 'secondary',\n        },\n        className // 외부에서 주입된 클래스가 기존 클래스와 병합/덮어쓰기됨\n      )}\n      {...props}\n    />\n  );\n}\n\n// MUST NOT: 인라인 스타일 사용\n<button style={{ backgroundColor: 'blue', color: 'white', padding: '8px 16px' }}>Click me</button>\n// Explanation: 인라인 스타일은 TailwindCSS의 일관된 디자인 시스템(테마)을 무시하고 유지보수를 어렵게 만듭니다.\n```\n\n## 4\\. Code Style Rules\n\n### MUST Follow (필수):\n\n  * **코드 포매팅:** **Prettier**를 사용하여 코드를 자동 포맷합니다. (일관된 들여쓰기: 2 스페이스, `singleQuote: true`, `trailingComma: 'es5'`)\n      * 이유: 프로젝트 전체의 코드 스타일 일관성 확보.\n  * **린팅:** **ESLint** (및 TypeScript ESLint)를 사용하여 잠재적 오류를 잡고 코드 스타일 규칙을 강제합니다.\n      * 이유: 오류 방지 및 코드 품질 유지.\n  * **네이밍 컨벤션:**\n      * 변수, 함수: `camelCase` (e.g., `userName`, `calculateTotal`).\n      * 컴포넌트, 타입/인터페이스: `PascalCase` (e.g., `UserProfile`, `IProject`).\n      * 상수: `UPPER_SNAKE_CASE` (e.g., `API_URL`, `MAX_USERS`).\n      * 이유: 코드 가독성 및 유지보수성 향상.\n  * **주석:** 복잡한 로직이나 명확하지 않은 코드를 설명하기 위해 명확하고 간결한 주석을 작성합니다. 함수와 컴포넌트에는 JSDoc 스타일의 주석을 권장합니다.\n      * 이유: 코드 이해 및 유지보수 용이성.\n  * **테스트:** 모든 중요 컴포넌트와 함수에 대해 단위 테스트(Unit Test) 및 통합 테스트(Integration Test)를 작성합니다. (예: `Jest`, `React Testing Library` 사용)\n      * 이유: 코드 품질 보장 및 리팩토링 시 회귀(regression) 방지.\n  * **접근성 (Accessibility):** WCAG 2.1 AA 표준을 준수합니다. 시맨틱 HTML 사용, 이미지에 `alt` 텍스트 제공, 충분한 색상 대비, 키보드 네비게이션 보장.\n      * 이유: 모든 사용자가(특히 시니어 사용자) 플랫폼을 원활하게 사용할 수 있도록 보장.\n  * **에러 핸들링:** 예기치 않은 오류를 정상적으로 처리하기 위해 견고한 에러 핸들링을 구현합니다. 오류를 기록하고 사용자 친화적인 에러 메시지를 표시합니다.\n      * 이유: 애플리케이션 충돌 방지 및 사용자 경험 향상.\n  * **보안 모범 사례:** 사용자 입력값 검증(Sanitize), SQL 인젝션 방지(Supabase RLS로 대부분 해결), XSS(Cross-Site Scripting) 공격 방어. 모든 통신은 HTTPS 사용.\n      * 이유: 사용자 데이터와 플랫폼을 보안 위협으로부터 보호.\n\n### MUST NOT Do (금지):\n\n  * **전역 변수:** 전역 변수 사용을 피합니다. 모듈이나 React Context, Zustand 등을 사용합니다.\n      * 이유: 전역 변수는 네이밍 충돌을 일으키고 코드 추론을 어렵게 만듭니다.\n  * **매직 넘버 (Magic Numbers):** 설명 없는 숫자 값을 코드에 직접 사용하지 않습니다. 명명된 상수로 대체합니다.\n      * 이유: 코드 가독성 향상.\n  * **중첩된 콜백 (Callback Hell):** 깊게 중첩된 콜백을 피합니다. Promises나 `async/await`를 사용합니다.\n      * 이유: 코드 가독성 및 유지보수성 향상.\n  * **`console.log` (프로덕션):** 프로덕션 빌드에 `console.log`, `console.warn` 등을 남기지 않습니다. (린트 규칙으로 제거)\n      * 이유: 민감한 정보 유출 가능성 및 성능 저하.\n  * **보안 취약점 무시:** 린터나 보안 스캐너가 보고하는 보안 취약점을 절대 무시하지 않고 즉시 조치합니다.\n      * 이유: 플랫폼이 공격에 노출될 수 있습니다.\n  * **과도한 엔지니어링 (Over-engineering):** 현재 요구사항에 집중하고 코드를 단순하게 유지합니다.\n      * 이유: 불필요한 복잡성은 유지보수를 어렵게 만듭니다.\n  * **시크릿 커밋 (Committing Secrets):** API 키, DB 비밀번호 등 민감 정보를 **절대** Git 리포지토리에 커밋하지 않습니다. 환경 변수를 사용합니다.\n      * 이유: 민감 정보가 외부에 노출됩니다.\n  * **긴 함수 (Long Functions):** 함수는 단일 책임 원칙(SRP)을 따르고, 가능한 짧게(이상적으로 50줄 미만) 유지합니다. 큰 함수는 더 작고 관리하기 쉬운 단위로 분리합니다.\n      * 이유: 가독성 및 테스트 용이성 향상.\n\n## 5\\. Architecture Patterns\n\n  * **컴포넌트 기반 아키텍처:** UI는 재사용 가능한 React 컴포넌트 (서버/클라이언트 구분)로 구축합니다.\n  * **데이터 흐름:** 데이터는 부모에서 자식 컴포넌트로 단방향(props)으로 흐릅니다. 자식에서 부모로의 데이터 전달은 콜백 함수를 사용합니다.\n  * **상태 관리 (State Management):**\n      * 컴포넌트 로컬 상태: `useState` 사용.\n      * 공유 상태 (복잡함): **Zustand**를 우선적으로 고려합니다. (간단하고 강력하며 보일러플레이트가 적음)\n      * 정적 데이터 (테마, 인증 상태): React Context 사용.\n  * **API 설계 (App Router):**\n      * `app/api/`의 라우트 핸들러는 RESTful 원칙을 따릅니다.\n      * API 라우트는 Supabase 및 OpenAI API의 **보안 게이트웨이** 역할을 하며, 인증 및 핵심 비즈니스 로직(검증 등)만 처리하고 최대한 가볍게 유지합니다.\n      * 데이터 변경(C/U/D)은 **Server Actions** 사용을 적극 권장합니다.\n  * **아키텍처 레이어 (Next.js App Router 기준):**\n      * **프레젠테이션 (Presentation):** `app/` 디렉터리의 React 서버 및 클라이언트 컴포넌트.\n      * **비즈니스 로직 / API (Logic/API):** `app/api/`의 라우트 핸들러 및 `Server Actions`.\n      * **데이터 접근 (Data Access):** `lib/` 폴더 내의 Supabase/OpenAI 클라이언트 래퍼(wrapper) 함수.\n\n<!-- end list -->\n\n```typescript\n// MUST: 재사용 가능한 프레젠테이션 컴포넌트\n// components/ui/Button.tsx\nimport { cn } from '@/lib/utils';\n\n// (ButtonProps 정의...)\n\nfunction Button({ className, variant, ...props }: ButtonProps) {\n  return (\n    <button\n      className={cn(/* ... Tailwind 클래스 ... */, className)}\n      {...props}\n    />\n  );\n}\n\n// MUST NOT: 컴포넌트 내에서 과도한 비즈니스 로직/데이터 페칭 혼합\n// app/dashboard/BadButton.tsx ('use client') - (안티 패턴)\nfunction BadButton() {\n    const [data, setData] = useState(null)\n\n    // 컴포넌트가 직접 데이터 페칭 로직을 모두 소유 (재사용 불가)\n    useEffect(() => {\n        fetch('/api/getData')\n            .then(res => res.json())\n            .then(setData)\n            // 에러 처리 누락\n    }, [])\n\n    return (\n        <div>\n            {data ? <p>Data: {data.value}</p> : <p>Loading...</p>}\n            <button>Click</button> \n        </div>\n    )\n}\n// Explanation: 이 컴포넌트는 데이터 페칭과 UI 로직이 강하게 결합되어 있습니다.\n// 재사용이 불가능하며 테스트하기 어렵습니다. 데이터 페칭은 상위 서버 컴포넌트나 커스텀 훅(useQuery 등)으로 분리해야 합니다.\n```",
      "writedAt": "2025-10-25T11:38:34.666Z"
    },
    {
      "type": "design-guide",
      "content": "# ECHO (AI 자서전 플랫폼) Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n- 컨셉: Friendly and Warm(친근하고 따뜻함), 둥근 모서리와 여백 중심\n- 무드 키워드: 공감, 안정감, 서재, 가족 앨범, 담담한 즐거움\n- 왜 이렇게?: \n  - PRD의 핵심 가치(공감형 AI 인터뷰, 자동 서사 구조화)와 시니어 친화 UX 요구에 최적\n  - 사용자 여정에서 회상-성취-감동의 감정 곡선을 부드럽게 지지\n  - PIPA 준수와 신뢰성 전달을 위해 과도한 트렌디/미래지향보다 친근·차분 톤 유지\n- 톤 앤 매너(마이크로카피 예시):\n  - 온보딩: “정답은 없어요. 편하게 이야기해 주세요, 캡틴.”\n  - 인터뷰: “어제의 이야기, 참 따뜻했어요. 오늘은 학창 시절을 이어가볼까요?”\n  - 완성 단계: “이제 거의 다 왔어요. 표지를 꾸미면 한 권의 책이 됩니다.”\n\n## 2. Reference Service (참조 서비스)\n- Name: Storyworth\n- Description: 가족에게 매주 질문을 보내 답변을 모아 책으로 만들어주는 서비스\n- Design Mood: 따뜻한 중저채도, 클래식한 서체감, 여백과 차분한 포레스트 그린 포인트\n- Primary Color: #2E5E4E\n- Secondary Color: #F4EDE4\n\n## 3. Color & Gradient (색상 & 그라데이션)\n- Primary: #2E5E4E (Forest Green) — 메인 CTA, 링크, 강조 텍스트\n- Secondary: #F4EDE4 (Warm Ivory) — 배경/서피스, 장시간 읽기 친화\n- Accent 1: #E46D5E (Warm Coral) — 진행률/알림/배지\n- Accent 2: #F0B27A (Apricot) — 보조 버튼/칩\n- Grayscale\n  - Ink 900: #1C1C1C (본문/제목)\n  - Ink 700: #3E3E3E (보조 텍스트)\n  - Ink 500: #6F6F6F (메모/플레이스홀더)\n  - Ink 300: #C8C8C8 (구분선/비활성)\n  - Ink 100: #F5F5F4 (콘텐츠 블록 배경)\n- State\n  - Success: #3A9D72\n  - Warning: #E6A23C\n  - Error: #D64545\n- Mood: Warm, 저~중채도, 명도 대비 AA 기준 준수(본문 18px+ 기준)\n- Subtle Gradient(옵션): #F4EDE4 → #FFFFFF (히어로/섹션 전환 배경, 눈부심 최소화)\n\nColor Usage(우선순위별)\n- Primary 실색 + 흰 텍스트: “이어 쓰기”, “완성”, “AI 초안 생성”\n- Secondary: 페이지/카드 배경, 장문 읽기 레이아웃\n- Accent 1/2: 진행률, 상태 배지, 온보딩 하이라이트\n- Grayscale: 정보 계층화(제목-본문-메모), 비활성/분리선\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n- 기본 폰트: Pretendard(가독성 우수, KR 최적) / 대체: Noto Sans KR, Apple SD Gothic Neo, Segoe UI\n- 본문 가독성 기준: 본문 최소 18px, line-height 1.6, 문단 간격 12–16px\n- 스타일\n  - H1: 40px, 700, lh 1.2\n  - H2: 32px, 700, lh 1.25\n  - H3: 24px, 600, lh 1.3\n  - H4: 20px, 600, lh 1.4\n  - Body L: 18px, 400, lh 1.6 (기본 본문)\n  - Body M: 16px, 400, lh 1.6 (보조, 태블릿)\n  - Caption: 14px, 400, lh 1.4 (라벨/주석)\n- 접근성\n  - 링크/버튼 텍스트 대비 AA 이상\n  - 최대 줄 길이 65–75자(Desktop), 50–65자(Tablet)\n  - 숫자·고유명사 가독성 위해 Tabular Numbers 옵션(가능 시)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n- 그리드: Desktop 12col / 80–96px Gutter / Max width 1200–1280px, Tablet 8col\n- 원칙\n  - One Task per Screen: 한 화면에 한 과업(시니어 인지부하 최소화)\n  - 고정 하단 액션바: 기본/보조 CTA를 항상 눈높이에서 제공\n  - 넉넉한 여백과 큰 클릭 타겟(최소 48x48px)\n- IA 제안(여정 기반)\n  1) 방문&온보딩: 히어로(데모 보기) → 3-Step 튜토리얼(건너뛰기 가능) → 간편 가입\n  2) 프로젝트 생성: “새 자서전” → 제목/한줄소개 → 기본 목차(연대별) 자동 제안\n  3) AI 인터뷰: \n     - 좌: 질문 카드(한 문항), 난이도 슬라이더\n     - 중: 채팅 캔버스(대화), STT 버튼, STT 실시간 텍스트 박스(즉시 수정)\n     - 우: 글감 보관함, 사진 1–2장 업로드, 다음 질문 프리뷰\n  4) 서사 구조화: 자동 챕터 초안 + 진행률(예: 65%) + Drag&Drop 순서 변경\n  5) 편집·검토: 문단 선택 → “톤 다듬기(따뜻하고 담담하게 등)” → 변경점 하이라이트/되돌리기 타임라인\n  6) 완성·출판: 표지 업로드 → PDF 미리보기 → POD 주문(추가 인쇄 제안)\n\n## 6. Visual Style (비주얼 스타일)\n- 아이콘: 둥근 코너의 라운드 스트로크(2px), 단색 + Ink 700, 상태는 Accent 사용\n- 이미저리: 가족 앨범/문집 느낌의 사진, 약한 필름 그레인(옵션), 8–12px 라운드 코너\n- 일러스트: 플랫+소프트 섀도, 따뜻한 아이보리 배경 위 낮은 채도 포인트\n- 사진 프레임: 캡션 박스 포함(본문 Body M), 사진 대비 보정을 위한 얇은 테두리 #EDE8E0\n- Skeleton/Empty States:\n  - Empty 글감 보관함: “떠오르는 단어 한 개만 적어도 좋아요.”\n  - 인터뷰 대기: 마이크 아이콘 펄스 애니메이션(1.2s)\n\n## 7. UX Guide (UX 가이드)\n- 타깃: 전문가+초심자(둘 다). 초심자 우선, 전문가 효율 강화.\n- 초심자 흐름\n  - 3-Step 온보딩(목적 선택 → 인터뷰 방식 선택(음성/텍스트) → 첫 질문 시작)\n  - 친절한 언어와 예시 답변 카드(“예: 초등학교 운동장에서 놀던 기억”)\n  - STT 즉시 수정 UI를 가장 가까이 배치, 오탈자 자동 하이라이트\n  - 맥락형 코치마크: 첫 3회차까지 주요 버튼에 1줄 가이드\n- 전문가 흐름\n  - Outline-First 모드: 먼저 목차/챕터를 잡고 각 섹션에 에피소드 배치\n  - 키보드 숏컷: N(새 질문), Cmd/Ctrl+Enter(응답 저장), G(글감 보관함 열기)\n  - 벌크 업로드(텍스트/사진), 드래그 멀티선택, 빠른 톤 프리셋\n- 공감형 인터뷰 경험\n  - 질문 난이도 슬라이더(쉬움/보통/깊게)\n  - 장기 맥락 리마인드: “지난번 ‘첫 월급날’ 이야기를 여기에 이어둘까요?”\n  - 감정 안전장치: 민감한 질문에는 “건너뛰기” 버튼을 동일 가중치로 배치\n- 진행 동기 설계(KPI 연결)\n  - Activation(24h 내 첫 에피소드): 첫 로그인 시 “1분 만에 첫 이야기 남기기” 즉시 진입\n  - Weekly Retention: 주 1회 카카오/이메일 “새 질문이 준비됐어요!”\n  - Core Feature Adoption: 인터뷰 3개 완료 시 “AI 초안 생성” CTA 강조\n  - 완성 유도: 50% “절반을 지났어요”, 90% “표지를 꾸며보세요!” 배너\n- 신뢰/보안(PIPA)\n  - 동의 관리 대시보드 상시 노출(데이터 한국 리전 저장 표시, 다운로드/삭제 버튼)\n  - RAG 정책 안내: “원본 텍스트를 사실의 기준으로 사용합니다.”\n- 접근성\n  - 텍스트 18px+, 명확한 포커스 링(2px, #2E5E4E 60% 불투명)\n  - 버튼 최소 48x48px, 인터랙션 거리 줄이기(하단 고정 CTA)\n  - 오류 예방: 음성 입력 후 자동 재생 확인 옵션, 되돌리기 전역 히스토리\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n- 버튼(Button)\n  - Primary Filled: 배경 #2E5E4E, 텍스트 #FFFFFF, Radius 12px, L(56px 높이)\n  - Secondary Ghost: 텍스트 #2E5E4E, 테두리 #2E5E4E33, 배경 투명\n  - Tertiary Text: 텍스트 #E46D5E, Hover 시 밑줄\n  - 상태: Hover(5% 어둡게), Focus(2px 포커스 링), Disabled(불투명도 40%)\n- 입력(Input)\n  - 필드 높이 56px, 라운드 12px, 내부 패딩 16px\n  - 플레이스홀더 Ink 500, 오류 시 테두리 #D64545 + 도움말 텍스트\n- STT 레코더\n  - 원형 메인 버튼(64px), 펄스 애니메이션\n  - 실시간 텍스트 박스 인라인 편집, 오인식 단어 밑줄 점선\n  - “다시 듣기/다시 말하기” 동등 강조\n- 채팅 버블(Chat)\n  - 사용자 버블: Secondary 배경, AI 버블: 화이트 배경 + 연한 테두리\n  - 아바타: AI는 따뜻한 손자/손녀 아이콘 컨셉\n- 카드(Card)\n  - 그림자 매우 약하게(0, 4, 12, rgba(0,0,0,0.06)), Radius 16px\n  - 제목(H4) + 본문(Body L) + 보조메타(Caption)\n- 진행률(Progress)\n  - 라인 스타일, Accent 1 채움, 3단계 마커(50/65/90%)\n- 정렬/서사(Outline & Reorder)\n  - Drag Handle 명확, Drop 영역 하이라이트(#F0B27A33)\n  - 다중 선택 Shift+클릭\n- 미리보기/출판\n  - 우측 라이브 프리뷰(페이지 넘김), 인쇄 마진 가이드\n  - POD 주문 모달: 수량 선택, 예상 배송일, 추가 인쇄 할인 배지\n- 토스트/알림\n  - 성공: #3A9D72 배경 + 화이트 텍스트, 4초\n  - 경고/오류: 아이콘 + 문제 해결 액션 동반\n- 내비게이션\n  - 상단 스텝퍼: 온보딩/인터뷰/서사/편집/출판\n  - 좌측 최소 내비(선택): 현재 단계의 하위 메뉴만 노출\n\n—",
      "writedAt": "2025-10-25T11:38:34.666Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-10-25T11:38:34.666Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-10-25T11:38:34.666Z"
    }
  ]
}